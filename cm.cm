	J &out1
	B &halt




:ex3_
	J &ex3i		; call function to parse identifiers
	I &ex3e		; if successful, go to end of ex3
	
	J &ex3n		; call function to parse nested expressions
	I &ex3e		; if successful, go to end of ex3
	
	J &ex3m		; call function to parse modifiers e.g. .I/.N
	I &ex3e		; if successful, go to end of ex3

	J &ex3r		; call function to parse repeating expressions e.g. $ e
	I &ex3e		; if successful, go to end of ex3
	 		; if not successful, just return

:ex3e
	R
	

:ex3i
	L 'C'
	L ' '
	J &id__
	I &ex3j
	D
	R
:ex3j
	O
	R


:ex3n
	T '('
	I &ex3z
	R
:ex3z
	J &ex3_		; call ex3_ recursively
	E
	T ')'
	E
	R



:ex3m
	T '.'
	I &ex3o
	R
:ex3o
	T 'I'
	I &ex3p
	T 'N'
	I &ex3q
	R

:ex3p		; generate code for .I
	L 'A'
	O
	L 'I'
	L ' '
	G 1
	O
	L 'B'
	L ' '
	G 2
	O

	G 1
	F
	O
	L 'C'
	O
	L 'A'
	O
	L 'I'
	L ' '
	G 1
	O
	L 'N'
	O
	L 'I'
	L ' '
	G 1
	O
	L 'S'
	O
	
	G 2
	F
	O
	R


:ex3q		; generate code for .N
	L 'N'
	O
	L 'I'
	L ' '
	G 1
	O
	L 'B'
	L ' '
	G 2
	O
	
	G 1
	F
	O
	L 'C'
	O
	L 'N'
	O
	L 'I'
	L ' '
	G 1
	O
	L 'S'
	O
	
	G 2
	F
	O

	R


:ex3r
	T '$'
	I &ex3s
	R
:ex3s
	F
	G 1
	O
	J &ex3_
	L 'I'
	L ' '
	G 1
	O
	L 'S'
	O
	R

	
:out1
	J &outt
	I &ot1e
	J &outs
:ot1e
	R
	
	
:outt
	T '*'
	I &ott1
	R
:ott1
	T '1'
	I &oul1
	T '2'
	I &oul2
	B &ouco
	
	
:oul1	; compile label 1 output
	L 'G'
	L ' '
	L '1'
	O
	R

:oul2
	L 'G'
	L ' '
	L '2'
	O
	R

:ouco
	L 'C'
	O
	R


:outs	
	T '''
	I &ots1
	R
:ots1
	L 'C'
	L ' '
	L '''
	O

:ots2
	U '''
	I &ots3
	L 'C'
	L ' '
	L '''
	O
	R
	
:ots3
	L 'C'
	L ' '
	C
	O
	B &ots2
	
	


:id__
	A
	I &id2_
	B &idex
:id2_
	C
	A
	I &id2_
	N
	I &id2_
	S
:idex
	R
	
:halt
